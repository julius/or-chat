<!doctype html>
<html lang="de">
    <head>
        <meta charset="UTF-8" />
        <title>OR Chat</title>
        <style>
            body {
                font-family: sans-serif;
                max-width: 800px;
                margin: auto;
                padding: 2rem;
            }

            #chat {
                white-space: pre-wrap;
                border: 1px solid #ccc;
                padding: 1rem;
                height: 300px;
                overflow-y: auto;
                background-color: #fdfdfd;
                border-radius: 6px;
            }

            .message {
                margin-bottom: 1.2em;
                padding-bottom: 0.5em;
                border-bottom: 1px solid #eee;
                position: relative;
            }

            .message-content {
                margin-bottom: 0.2em;
            }

            .message-buttons {
                position: absolute;
                right: 0;
                top: -10px;
                display: flex;
                gap: 0.3em;
                opacity: 0;
                transition: opacity 0.2s ease;
                background: white;
                border-radius: 10px;
                box-shadow: 0 0 4px #333;
                padding: 0 0 8px 10px;
            }

            .message:hover .message-buttons {
                opacity: 1;
            }

            .message-buttons button {
                background: none;
                border: none;
                cursor: pointer;
                padding: 0.2em;
                font-size: 1rem;
                color: #888;
            }

            .message-buttons button:hover {
                color: #000;
            }

            textarea {
                width: 100%;
                height: 60px;
                margin-top: 1rem;
                padding: 0.5rem;
                font-family: inherit;
                font-size: 1em;
            }

            button {
                padding: 0.4rem 0.8rem;
                margin-top: 0.5rem;
                margin-right: 0.5rem;
                font-size: 0.9em;
                cursor: pointer;
            }

            /* Edit Modal */
            #editModal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 1000;
                display: none;
            }

            #editModalOverlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.4);
            }

            #editModalBox {
                position: absolute;
                top: 50%;
                left: 50%;
                width: 90%;
                max-width: 500px;
                background: white;
                padding: 1.5rem;
                border-radius: 8px;
                transform: translate(-50%, -50%);
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
            }

            #editModalBox h3 {
                margin-top: 0;
            }

            #editTextarea {
                width: 100%;
                height: 150px;
                font-size: 1em;
                font-family: inherit;
                margin-bottom: 1rem;
            }

            .modal-actions {
                text-align: right;
            }

            .modal-actions button {
                margin-left: 0.5rem;
            }

            #avatarPanel {
                width: 200px; /* match image width */
                text-align: center;
                flex-shrink: 0; /* prevent squishing on narrow screens */
            }

            #avatarImage {
                width: 200px;
                height: auto;
                border-radius: 10px;
                object-fit: cover;
                border: 1px solid #ccc;
            }

            #avatarUrlInput {
                width: 100%;
                font-size: 0.75em;
                padding: 0.3em;
                box-sizing: border-box;
                margin-top: 0.5rem;
            }

            .action-text {
                font-style: italic;
                color: #777;
            }

            .spoken-text {
                color: #2979ff; /* blue-ish */
            }
        </style>
    </head>
    <body>
        <div style="display: flex; gap: 1.5rem; align-items: flex-start">
            <div id="avatarPanel" style="display: none">
                <img id="avatarImage" src="" alt="Avatar" />
                <input type="text" id="avatarUrlInput" placeholder="Bild-URL einf√ºgen" />
            </div>

            <div style="flex: 1">
                <div id="chat"></div>
            </div>
        </div>

        <textarea id="userInput" placeholder="Schreibe eine Nachricht..."></textarea><br />
        <button onclick="sendMessage()">Senden</button>
        <button onclick="abortGeneration()">Abbrechen</button>
        <button onclick="clearChat()">Verlauf l√∂schen</button>

        <div style="padding: 20px 0 0 0">Model: <input type="text" id="modelId" style="width: 100%" /></div>

        <div style="padding: 20px 0 0 0">API-Key: <input type="text" id="apiKey" style="width: 100%" /></div>

        <div style="display: flex; gap: 1rem; margin-top: 1rem">
            <div style="flex: 1">
                <label for="systemLong"><strong>System Long</strong> <span id="systemLongTokenCount"></span></label>
                <br />
                <textarea id="systemLong" style="height: 100px"></textarea>
            </div>
            <div style="flex: 1">
                <label for="systemShort"><strong>System Short</strong> <span id="systemShortTokenCount"></span></label>
                <br />
                <textarea id="systemShort" style="height: 100px"></textarea>
            </div>
        </div>

        <!-- Edit Modal -->
        <div id="editModal">
            <div id="editModalOverlay" onclick="closeEditModal()"></div>
            <div id="editModalBox">
                <h3>Nachricht bearbeiten</h3>
                <textarea id="editTextarea"></textarea>
                <div class="modal-actions">
                    <button onclick="saveEditedMessage()">Speichern</button>
                    <button onclick="closeEditModal()">Abbrechen</button>
                </div>
            </div>
        </div>

        <script>
            const chatBox = document.getElementById('chat');
            const userInput = document.getElementById('userInput');

            let messages = [];
            let controller = null;
            let isGenerating = false;
            let editIndex = null;

            function generateId() {
                return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            // ==========================================
            // üê¢ SLOW PATH: Full Reconciliation
            // Use this ONLY for: Load, Add, Delete, Edit
            // ==========================================
            function renderMessages() {
                const currentIds = new Set(messages.map(m => m.id));

                // 1. Clean up deleted DOM nodes
                const children = Array.from(chatBox.children);
                for (let i = children.length - 1; i >= 0; i--) {
                    const child = children[i];
                    if (!currentIds.has(child.id)) {
                        child.remove();
                    }
                }

                // 2. Create or Update nodes
                messages.forEach((msg, index) => {
                    if (!msg.id) msg.id = generateId(); // Safety fix for old data

                    let messageEl = document.getElementById(msg.id);

                    // If element doesn't exist, create it (Standard DOM creation)
                    if (!messageEl) {
                        messageEl = createMessageElement(msg, index);
                        chatBox.appendChild(messageEl);
                    } else {
                        // If it exists, ensure the buttons have the correct index
                        // (Indexes change when messages are deleted!)
                        updateMessageButtons(messageEl, index);

                        // Check if content drifted (e.g. via Edit)
                        const contentDiv = messageEl.querySelector('.message-content');
                        if (contentDiv.getAttribute('data-raw') !== msg.content) {
                            contentDiv.innerHTML = formatMessageContent(msg);
                            contentDiv.setAttribute('data-raw', msg.content);
                        }
                    }

                    // Ensure DOM order matches Array order
                    // (appendChild moves existing elements to the end if they are already in DOM)
                    chatBox.appendChild(messageEl);
                });

                chatBox.scrollTop = chatBox.scrollHeight;
                localStorage.setItem('chatMessages', JSON.stringify(messages));
            }

            // ==========================================
            // üêá FAST PATH: Direct ID Update
            // Use this inside the Streaming Loop
            // ==========================================
            function updateStreamedMessage(id, content) {
                const messageEl = document.getElementById(id);

                // Safety fallback: If user deleted the element via DevTools WHILE streaming
                if (!messageEl) {
                    renderMessages();
                    return;
                }

                const contentDiv = messageEl.querySelector('.message-content');
                // Direct update, no loops, no checks on other messages
                contentDiv.innerHTML = renderStyledText(content);
                contentDiv.setAttribute('data-raw', content);

                // Efficient Scroll: Only if near bottom
                if (chatBox.scrollHeight - chatBox.scrollTop - chatBox.clientHeight < 100) {
                    chatBox.scrollTop = chatBox.scrollHeight;
                }
            }

            // --- Helper: Create Element ---
            function createMessageElement(msg, index) {
                const wrapper = document.createElement('div');
                wrapper.id = msg.id;
                wrapper.classList.add('message');

                const content = document.createElement('div');
                content.classList.add('message-content');
                content.innerHTML = formatMessageContent(msg);
                content.setAttribute('data-raw', msg.content);

                const actions = document.createElement('div');
                actions.classList.add('message-buttons');

                wrapper.append(content, actions);
                updateMessageButtons(wrapper, index); // Bind buttons
                return wrapper;
            }

            // --- Helper: Update Buttons ---
            function updateMessageButtons(element, index) {
                const actions = element.querySelector('.message-buttons');
                actions.innerHTML = ''; // Fast clear

                const btnProps = [
                    { text: '‚úèÔ∏è', title: 'Bearbeiten', onclick: () => openEditModal(index) },
                    { text: 'üóëÔ∏è', title: 'Entfernen', onclick: () => removeMessage(index) },
                    { text: '‚è©', title: 'Nachfolgende l√∂schen', onclick: () => removeAfter(index) },
                ];

                btnProps.forEach(prop => {
                    const btn = document.createElement('button');
                    btn.innerHTML = prop.text;
                    btn.title = prop.title;
                    btn.onclick = prop.onclick;
                    actions.appendChild(btn);
                });
            }

            // --- Helper: Format Content ---
            function formatMessageContent(msg) {
                const prefix = msg.role === 'user' ? 'üë§: ' : msg.role === 'system' ? 'üõ†Ô∏è: ' : '';
                return prefix + renderStyledText(msg.content);
            }

            // --- Your Existing Text Renderer ---
            function renderStyledText(text) {
                if (!text) return '';
                const escape = str =>
                    str.replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' })[c]);

                let result = '';
                let mode = 'normal';
                let buffer = '';

                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    if (char === '*' && mode === 'normal') {
                        if (buffer) result += escape(buffer);
                        buffer = '';
                        mode = 'action';
                        continue;
                    }
                    if (char === '*' && mode === 'action') {
                        result += `<span class="action-text">${escape(buffer)}</span>`;
                        buffer = '';
                        mode = 'normal';
                        continue;
                    }
                    if (char === `"` && mode === 'normal') {
                        if (buffer) result += escape(buffer);
                        buffer = '';
                        mode = 'spoken';
                        continue;
                    }
                    if (char === `"` && mode === 'spoken') {
                        result += `<span class="spoken-text">"${escape(buffer)}"</span>`;
                        buffer = '';
                        mode = 'normal';
                        continue;
                    }
                    buffer += char;
                }
                if (buffer) {
                    if (mode === 'action') result += `<span class="action-text">${escape(buffer)}</span>`;
                    else if (mode === 'spoken') result += `<span class="spoken-text">"${escape(buffer)}</span>`;
                    else result += escape(buffer);
                }
                return result;
            }

            // --- MAIN SEND FUNCTION ---
            async function sendMessage() {
                if (isGenerating) return;
                const userMessage = userInput.value.trim();

                if (userMessage) {
                    messages.push({ role: 'user', content: userMessage, id: generateId() });
                }

                isGenerating = true;

                // 1. Initial Render (Adds the user message to DOM)
                renderMessages();

                controller = new AbortController();
                const signal = controller.signal;

                // 2. Prepare AI Message
                const aiId = generateId(); // Generate ID immediately
                const aiMessage = { role: 'assistant', content: '', id: aiId };
                messages.push(aiMessage);

                // 3. Render again to put the empty AI container in the DOM
                renderMessages();

                try {
                    const systemLong = document.getElementById('systemLong').value.trim();
                    const systemShort = document.getElementById('systemShort').value.trim();
                    const payloadMessages = [];

                    if (systemLong) payloadMessages.push({ role: 'system', content: systemLong });

                    const nonSystem = messages.filter(m => m.role !== 'system');
                    // Prepare context (Last N messages)
                    const latestMessages = nonSystem.map(m => ({ role: m.role, content: m.content }));

                    if (systemShort && latestMessages.length >= 2) {
                        latestMessages.splice(latestMessages.length - 2, 0, { role: 'system', content: systemShort });
                    }
                    payloadMessages.push(...latestMessages);

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            Authorization: 'Bearer ' + document.getElementById('apiKey').value,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            model: document.getElementById('modelId').value,
                            messages: payloadMessages,
                            stream: true,
                        }),
                        signal,
                    });

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder('utf-8');

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value, { stream: true });
                        const lines = chunk.split('\n').filter(line => line.startsWith('data: '));

                        for (const line of lines) {
                            const jsonStr = line.replace(/^data: /, '').trim();
                            if (jsonStr === '[DONE]') break;
                            try {
                                const parsed = JSON.parse(jsonStr);
                                const content = parsed.choices?.[0]?.delta?.content || '';
                                aiMessage.content += content;

                                // ‚úÖ CRITICAL CHANGE:
                                // Call the fast path. No loops. Direct ID access.
                                updateStreamedMessage(aiId, aiMessage.content);
                            } catch (e) {
                                console.error(e);
                            }
                        }
                    }
                } catch (err) {
                    if (err.name === 'AbortError') {
                        aiMessage.content += '\n[‚õî Generierung abgebrochen]';
                        updateStreamedMessage(aiId, aiMessage.content);
                    } else {
                        console.error(err);
                    }
                } finally {
                    isGenerating = false;
                    controller = null;
                    userInput.value = '';
                    localStorage.setItem('chatMessages', JSON.stringify(messages));
                    // Optional: One final full render to ensure perfect state,
                    // though not strictly necessary if updateStreamedMessage works.
                    // renderMessages();
                }
            }

            // --- STANDARD UTILS ---
            function abortGeneration() {
                if (controller) controller.abort();
            }

            function clearChat() {
                localStorage.removeItem('chatMessages');
                messages = [];
                renderMessages();
            }

            function removeMessage(index) {
                messages.splice(index, 1);
                renderMessages();
            }

            function removeAfter(index) {
                messages = messages.slice(0, index + 1);
                renderMessages();
            }

            function openEditModal(index) {
                editIndex = index;
                document.getElementById('editTextarea').value = messages[index].content;
                document.getElementById('editModal').style.display = 'block';
            }

            function closeEditModal() {
                editIndex = null;
                document.getElementById('editModal').style.display = 'none';
            }

            function saveEditedMessage() {
                const newText = document.getElementById('editTextarea').value.trim();
                if (editIndex !== null && newText !== '') {
                    messages[editIndex].content = newText;
                    renderMessages();
                    closeEditModal();
                }
            }

            // --- INIT ---
            window.addEventListener('DOMContentLoaded', () => {
                const saved = localStorage.getItem('chatMessages');
                if (saved) {
                    try {
                        messages = JSON.parse(saved);
                        messages.forEach(m => {
                            if (!m.id) m.id = generateId();
                        });
                    } catch (e) {
                        console.error(e);
                    }
                }
                renderMessages();

                // Restore inputs
                ['modelId', 'apiKey', 'systemLong', 'systemShort'].forEach(id => {
                    const el = document.getElementById(id);
                    el.value = localStorage.getItem(id) || '';
                    el.addEventListener('input', () => localStorage.setItem(id, el.value));
                });

                // Avatar
                const avatarImage = document.getElementById('avatarImage');
                const avatarUrlInput = document.getElementById('avatarUrlInput');
                avatarUrlInput.addEventListener('input', () => {
                    avatarImage.src = avatarUrlInput.value;
                    localStorage.setItem('avatarUrl', avatarUrlInput.value);
                });
                const savedAv = localStorage.getItem('avatarUrl');
                if (savedAv) {
                    avatarUrlInput.value = savedAv;
                    avatarImage.src = savedAv;
                }
            });
        </script>
    </body>
</html>
